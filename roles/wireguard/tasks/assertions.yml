---
- name: Verify server's IP
  assert:
    that: wg_server_ip | ipv4
    success_msg: "Server's private IP: {{ wg_server_ip }}"
    fail_msg: "Incorrect server IP: {{ wg_server_ip }}"

- name: Verify that server`s IP is within its subnet
  assert:
    that: wg_server_ip | ipv4(wg_server_subnet)
    success_msg: "Provisioning subnet: {{ wg_server_subnet }}"
    fail_msg: "Incorrect server subnet: {{ wg_server_subnet }}"

- name: Verify Wireguard port
  assert:
    that: wg_port | int > 1 and wg_port | int < 65535
    success_msg: "Server will be listening on port {{ wg_port }}"
    fail_msg: "Invalid port number: {{ wg_port }}"

- name: Verify interface name
  assert:
    that: wg_iface | length > 1
    success_msg: "Wireguard interface: {{ wg_iface }}"
    fail_msg: "Invalid interface name: {{ wg_iface }}"

- name: Verify peers' names
  assert:
    that:
      - item.name | length > 1
      - item.name is search("^[a-zA-Z0-9]*$")
    success_msg: "Deploying peer: {{ item.name }}"
    fail_msg: "Invalid peer name: {{ item.name }}"
    quiet: yes
  loop: "{{ wg_clients }}"
  loop_control:
      label: "{{ item.name }}"
  when: wg_clients | length > 0

- name: Verify peers' IPs
  assert:
    that:
      - item.ip | ipv4(wg_server_subnet)
    success_msg: "Deploying peer with IP: {{ item.ip }}"
    fail_msg: "Peer {{ item.ip }} is outside of server's subnet {{ wg_server_subnet }}"
    quiet: yes
  loop: "{{ wg_clients }}"
  loop_control:
      label: "{{ item.ip }}"
  when: wg_clients | length > 0

#
# This block serves as an illustration why trying to make DSL into a
# full-featured language isn't the best idea. Use the right tools.
#

- name: Register all interfaces of the target host
  set_fact:
    wg_existing_ifaces: "{{ hostvars[inventory_hostname]\
                          ['ansible_%s' | format(item)]['ipv4'] }}"
  loop: "{{ ansible_interfaces }}"
  register: wg_existing_ifaces_parsed

- name: Parse the results
  set_fact:
    wg_existing_ifaces_mini: "{{ wg_existing_ifaces_parsed.results\
                              | json_query( '[*].ansible_facts.wg_existing_ifaces' )}}"

- name: Construct address/netmask pairs in CIDR format
  set_fact:
    wg_addr_plus_netmask: "{{ wg_addr_plus_netmask\
                            + [item['address'] + '/' + item['netmask']] }}"
    wg_addr_individual: "{{ wg_addr_individual\
                          + [item['address'] | string] }}"
  with_items: "{{ wg_existing_ifaces_mini }}"
  vars:
    wg_addr_plus_netmask: []
    wg_addr_individual: []

- name: Register address/netmask pairs in CIDR format
  set_fact:
    wg_addr_incl_netmask_ready: "{{ wg_addr_incl_netmask_ready\
                                  + [item | ipaddr('network/prefix')] }}"
  with_items: "{{ wg_addr_plus_netmask }}"
  vars:
    wg_addr_incl_netmask_ready: []

- name: Register subnets on target that overlap with the `wg_server_subnet`
  set_fact:
    wg_overlap_networks: "{{ wg_overlap_networks + \
                  [hostvars[inventory_hostname]\
                  ['ansible_%s' | format(item)]\
                  ['ipv4']['network']\
                  | ipaddr(wg_server_subnet)\
                  | string] }}"
  loop: "{{ ansible_interfaces }}"
  vars:
    - wg_overlap_networks: []

- name: Remove invalid network and addresses
  set_fact:
    wg_overlap_networks: "{{ wg_overlap_networks\
                          | difference(wg_null) }}"
  vars:
    - wg_null: ['null', None]

- name: Separate addresses
  set_fact:
    wg_addresses: "{{ lookup('flattened', wg_overlap_networks\
                    | zip_longest(wg_addr_incl_netmask_ready,wg_addr_individual)\
                    | list) | ipaddr('address') | unique\
                    | difference(['127.0.0.1'])}}"

- name: Filter addresses
  set_fact:
    wg_addresses_filtered: "{{ wg_addresses_filtered + [item] }}"
  with_items: "{{ wg_addresses }}"
  when: item | ipaddr(wg_server_subnet) | ipaddr('bool')
  vars:
    wg_addresses_filtered: []

- name: Filter and separate networks
  set_fact:
    wg_networks: "{{ lookup('flattened', wg_overlap_networks\
                  | zip_longest(wg_addr_incl_netmask_ready)\
                  | list) | ipaddr('net') | unique }}"
  when: wg_addresses_filtered is defined

- name: Create dictionary to correlate all the findings about network
  set_fact:
    wg_combodict: "{{ wg_combodict | combine({item:wg_addresses_filtered}) }}"
  with_items: "{{ wg_networks }}"
  when: wg_networks is defined and wg_addresses_filtered is defined
  vars:
    wg_combodict: {}

- name: Correlate findings about network and register overlapping IPs
  set_fact:
    wg_ips_to_correlate: "{{ wg_ips_to_correlate\
                          + [item.1 | ipaddr(item.0.key)] }}"
  when:
      - wg_combodict is defined
      - item.1 | ipaddr(item.0.key) | ipaddr('bool')
  loop: "{{ wg_combodict | dict2items | subelements('value') }}"
  vars:
    wg_ips_to_correlate: []

- name: Find which interfaces are affected
  findif:
    address: "{{ item }}"
  with_items: "{{ wg_ips_to_correlate }}"
  when: wg_ips_to_correlate is defined
  changed_when: false
  register: wg_overlap_ifaces

- name: Register affected interfaces
  set_fact:
    wg_affected_ifaces: "{{ wg_affected_ifaces + [item.interface | string] }}"
    wg_affected_addresses: "{{ wg_affected_addresses + [item.item] }}"
  with_items: "{{ wg_overlap_ifaces.results }}"
  when:
    - wg_overlap_ifaces.results is defined
    - item.interface != None
  vars:
    wg_affected_ifaces: []
    wg_affected_addresses: []

- name: Assert there is only one affected interface and it has â‰¥1 IPs
  assert:
    that:
      - wg_affected_ifaces | length == 1
      - wg_affected_addresses | length >= wg_affected_ifaces | length
    fail_msg: "There is more than one interface with overlapping subnet.\n\
                It is best to check {{ wg_affected_ifaces }} manually.\n\
                Affected IPs: {{ wg_affected_addresses }}"
    success_msg: "One overlapping interface detected:\n\
                  '{{ wg_affected_ifaces[0] }}', with an address of \
                  {{ wg_affected_addresses[0] }}"
  register: wg_affected_single
  when:
    - wg_affected_ifaces is defined
    - wg_affected_addresses is defined

# TODO: Verify that output of `cat /etc/wireguard/{{ wg_iface}}.conf has Address == to the wg_affected_addresses[0]

- name: Extract IP from a Wireguard config
  shell:
    cmd: "grep Address /etc/wireguard/{{ wg_iface }}.conf | cut -d' ' -f3 | xargs"
  register: wg_existing_config_ip
  changed_when: false

- name: Ensure that subnet from Wireguard config overlaps with the detected IP
  assert:
    that:
      - wg_affected_addresses[0] | ipaddr(wg_existing_config_ip.stdout | string)
    fail_msg: "Subnet '{{ wg_existing_config_ip.stdout }}' found in \
                the Wireguard config does not overlap with the address \
                '{{ wg_affected_addresses[0] }}' detected above.\n\
                Please investigate before continuing."
    success_msg: "Subnet '{{ wg_existing_config_ip.stdout }}' found in \
                the Wireguard config includes '{{ wg_affected_addresses[0] }}'.\n\
                Proceeding with overwriting it."
  when:
    - wg_overwrite
    - wg_affected_ifaces is defined
    - wg_affected_addresses is defined

- name: Ensure that found interface is managed by Wireguard _now_
  shell:
    cmd: "wg show {{ wg_affected_ifaces[0] }}"
  register: wg_affected_shellcheck
  failed_when: wg_affected_shellcheck.rc > 0
  when:
    - wg_overwrite
    - wg_affected_ifaces is defined
    - wg_affected_addresses is defined

- name: Assert that we can destroy the interface
  assert:
    that:
      - wg_overwrite
      - wg_affected_ifaces[0] == wg_iface
    success_msg: "Requested subnet of {{ wg_server_subnet }} overlaps with \
                  the {{ wg_affected_addresses[0] }}.\nOverwriting interface \
                  '{{ wg_affected_ifaces[0] }}' on the target host."
    fail_msg: "Requested subnet of {{ wg_server_subnet }} overlaps with \
                the {{ wg_affected_addresses[0] }}.\nRequested interface \
                '{{ wg_iface }}' would overlap with '{{ wg_affected_ifaces[0] }}' \
                on the target host.\n\
                `wg_iface` must be set to '{{ wg_affected_ifaces[0] }}' \
                if you want to proceed."
  when: wg_affected_ifaces[0] is defined and wg_affected_ifaces[0] != None

#
# Nightmares end here.
#

- name: Verify peers' keys lengths
  assert:
    that:
      - item.pubkey | length == 44
      - item.psk | length == 44
    quiet: yes
    success_msg: "Client's keys are 44 symbols long"
    fail_msg: "Key length is wrong"
  loop: "{{ wg_clients }}"
  loop_control:
      label: "{{ item.name }}"
  when: wg_clients | length > 0

  # No usable config can be <2 bytes
- name: Check if there is an existing config
  find:
    paths: /etc/wireguard
    patterns: '{{ wg_iface }}.conf'
    size: '2'
  register: wg_existing_conf

- name: Check if there is an existing Wireguard interface
  command: wg show interfaces
  register: wg_existing_interfaces

- name: Load "listen_ports_facts" module
  listen_ports_facts:

- name: Save port state in a variable
  set_fact:
    wg_port_exists: "{{ wg_port in udp_listen | map(attribute='port') | flatten }}"

- name: Determine if detected WG instance is listening on the port we want to use
  shell:
    cmd: "wg show {{ wg_iface }} | head -5 | grep 'listening port:' | rev | cut -d' ' -f1 | rev"
  register: wg_iface_current_port

- name: Assert we are not trying to provision on a busy port without permission
  assert:
    that: not wg_port_exists
    success_msg: "Provisioning Wireguard on port {{ wg_port }}"
    fail_msg: "Port {{ wg_port }} is already occupied on the target host and 'wg_overwrite' is False"
  when:
    - not wg_overwrite
    - wg_existing_conf.files | length > 0

- name: Assert we are overwriting an existing WG instance listening on the same port
  assert:
    that: wg_iface_current_port.stdout | int == wg_port
    success_msg: "Port {{ wg_port }} is occupied by {{ wg_iface }} and will be replaced by the new WG instance"
    fail_msg: "Port {{ wg_port }} is already occupied by {{ wg_iface }} on the target host and 'wg_overwrite' is set to False"
  when:
    - wg_overwrite
    - wg_port_exists
    - wg_existing_conf.files | length > 0
    - wg_iface in wg_existing_interfaces.stdout
    - wg_iface_current_port.stdout | int == wg_port

- name: Assert that we are not overwriting config without permission
  assert:
    that: wg_existing_conf.files | length == 0
    fail_msg: "Config /etc/wireguard/{{ wg_iface }}.conf exists and 'wg_overwrite' is set to False"
    success_msg: "/etc/wireguard/{{ wg_iface }}.conf not found, continuing..."
  when: wg_overwrite is false

- name: Tear-down the existing Wireguard interface
  shell:
    cmd: "wg-quick down {{ wg_iface }}"
  when:
    - wg_overwrite
    - wg_existing_conf.files | length > 0
    - wg_iface in wg_existing_interfaces.stdout
